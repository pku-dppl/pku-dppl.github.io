---
layout: english
---

## Course Information

Room: Changping 109<br>
Time: Week 1--16, Monday, Lect. 7--9

## Syllabus

### Overview

In the past few decades, the development of programming languages has shown two distinct trends: (i) from simple low-level languages to complex high-level languages, and (ii) from a fixed small set of languages to many domain-specific languages. Traditional programming languages such as C and Java, which once dominated every programming language rankings, have been gradually surpassed by modern programming languages such as Python, JavaScript, Go, and Rust. On the one hand, many traditional languages have been evolving constantly and introducing various high-level language features. For example, the original design goal of Java was a simplified language, but the design of the latest Java has included many advanced features such as generics, functional programming, and dynamic features (e.g., reflection). On the other hand, more and more programming languages are constantly emerging to meet the needs of using specialized programming languages in specific application domains.<br>

In this situation, the ability to design new programming languages is no longer an exclusive superior skill of senior programming-language researchers or frontier computer scientists; instead, it has become a necessary ability for software developers. Meanwhile, understanding and mastering the principles of programming-language design can also help us better understand various new features in high-level programming languages and make better use of mainstream programming languages.<br>

In this course, we will address how the constantly emerging programming languages are designed, how new advanced language features are added to mainstream languages, and whether new programming paradigms such as object-oriented programming, functional programming, and generic programming have a common theoretical foundation.<br>

To guide the design of programming languages, researchers have proposed a series of principles and methodologies, the most central one among which is type theory. Type annotations provide a basic means to avoid programming errors in modern programming languages, and type theory provides both characterizations of well-behaved type systems and methods for formulating complex types. This course will teach modern programming-language theory and organize around type theory.<br>

This course has two characteristics: (i) rigor: all concepts in this course will have strict mathematical definitions that can be used by formal deduction and induction, rather than vague conceptual introductions, and (ii) practicality: all important concepts will be implemented through programming assignments and students can therefore master the knowledge through hands-on exercises. We hope that through this course, students will acquire a solid theoretical foundation and practical ability in the area of programming languages, as well as become capable of conducting programming-language-related research in academia and designing new programming languages in the industry.<br>

### Bibliography

[Types and Programming Languages](https://www.cis.upenn.edu/~bcpierce/tapl/), Benjamin C.Pierce, The MIT Press, 2002. (Textbook)

[Practical Foundations for Programming Languages](https://www.cs.cmu.edu/~rwh/pfpl/), Robert Harper, Cambridge University Press, 2016. (Reference)

### Schedule

<table border="1" cellspacing="1">
    <thead>
        <tr>
            <th>Class</th>
            <th>Date</th>
            <th>Topic and Readings</th>
            <th>Lecturer</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1</td>
            <td>17-Feb</td>
            <td>Introduction<br>Untyped Arithmetic Operations</td>
            <td>Zhao</td>
        </tr>
               <tr>
            <td>2</td>
            <td>24-Feb</td>
            <td>OCaml/MoonBit</td>
            <td>Zhao/Wang</td>
        </tr>
        <tr>
            <td>3</td>
            <td>3-Mar</td>
            <td>Lambda Calculus<br>Nameless Representation</td>
            <td>Zhao</td>
        </tr>
        <tr>
            <td>4</td>
            <td>10-Mar</td>
            <td>Type Basics<br>Simple Typed Lambda Calculus<br>Simple Extensions</td>
            <td>Zhao</td>
        </tr>
        <tr>
            <td>5</td>
            <td>17-Mar</td>
            <td>Reference</td>
            <td>Zhao</td>
        </tr>
        <tr>
            <td>6</td>
            <td>24-Mar</td>
            <td>Exception</td>
            <td>Zhao</td>
        </tr>
        <tr>
            <td>7</td>
            <td>31-Mar</td>
            <td>Subtyping<br>Metatheory of Subtyping</td>
            <td>Zhao</td>
        </tr>
        <tr>
            <td>8</td>
            <td>7-Apr</td>
            <td>Project Proposal<br>(Midterm Test)</td>
            <td>Zhao/Wang</td>
        </tr>
        <tr>
            <td>9</td>
            <td>14-Apr</td>
            <td>Recursive Types</td>
            <td>Wang</td>
        </tr>
        <tr>
            <td>10</td>
            <td>21-Apr</td>
            <td>Variable Types</td>
            <td>Wang</td>
        </tr>
        <tr>
            <td>11</td>
            <td>28-Apr</td>
            <td>Type-Level Computation</td>
            <td>Wang</td>
        </tr>
        <tr>
            <td>12</td>
            <td>5-May</td>
            <td>May Festival (No Class)</td>
            <td>/</td>
        </tr>
        <tr>
            <td>13</td>
            <td>12-May</td>
            <td>Type Inference</td>
            <td>Wang</td>
        </tr>
        <tr>
            <td>14</td>
            <td>19-May</td>
            <td>Substructural Types</td>
            <td>Wang</td>
        </tr>
        <tr>
            <td>15</td>
            <td>26-May</td>
            <td>Effect Types</td>
            <td>Wang</td>
        </tr>
        <tr>
            <td>16</td>
            <td>2-Jun</td>
            <td>Project Final Presentation</td>
            <td>Zhao/Wang</td>
        </tr>
    </tbody>
</table>
